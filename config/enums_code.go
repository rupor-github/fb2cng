// Code generated by go-enum DO NOT EDIT.
// Version: v0.9.2

// Built By: go install

package config

import (
	"fmt"
	"strings"
)

const (
	// FootnotesModeDefault is a FootnotesMode of type Default.
	FootnotesModeDefault FootnotesMode = iota
	// FootnotesModeFloat is a FootnotesMode of type Float.
	FootnotesModeFloat
)

var ErrInvalidFootnotesMode = fmt.Errorf("not a valid FootnotesMode, try [%s]", strings.Join(_FootnotesModeNames, ", "))

const _FootnotesModeName = "defaultfloat"

var _FootnotesModeNames = []string{
	_FootnotesModeName[0:7],
	_FootnotesModeName[7:12],
}

// FootnotesModeNames returns a list of possible string values of FootnotesMode.
func FootnotesModeNames() []string {
	tmp := make([]string, len(_FootnotesModeNames))
	copy(tmp, _FootnotesModeNames)
	return tmp
}

var _FootnotesModeMap = map[FootnotesMode]string{
	FootnotesModeDefault: _FootnotesModeName[0:7],
	FootnotesModeFloat:   _FootnotesModeName[7:12],
}

// String implements the Stringer interface.
func (x FootnotesMode) String() string {
	if str, ok := _FootnotesModeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("FootnotesMode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x FootnotesMode) IsValid() bool {
	_, ok := _FootnotesModeMap[x]
	return ok
}

var _FootnotesModeValue = map[string]FootnotesMode{
	_FootnotesModeName[0:7]:                   FootnotesModeDefault,
	strings.ToLower(_FootnotesModeName[0:7]):  FootnotesModeDefault,
	_FootnotesModeName[7:12]:                  FootnotesModeFloat,
	strings.ToLower(_FootnotesModeName[7:12]): FootnotesModeFloat,
}

// ParseFootnotesMode attempts to convert a string to a FootnotesMode.
func ParseFootnotesMode(name string) (FootnotesMode, error) {
	if x, ok := _FootnotesModeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _FootnotesModeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return FootnotesMode(0), fmt.Errorf("%s is %w", name, ErrInvalidFootnotesMode)
}

// MustParseFootnotesMode converts a string to a FootnotesMode, and panics if is not valid.
func MustParseFootnotesMode(name string) FootnotesMode {
	val, err := ParseFootnotesMode(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x FootnotesMode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *FootnotesMode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseFootnotesMode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *FootnotesMode) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// ImageResizeModeNone is a ImageResizeMode of type None.
	ImageResizeModeNone ImageResizeMode = iota
	// ImageResizeModeKeepAR is a ImageResizeMode of type KeepAR.
	ImageResizeModeKeepAR
	// ImageResizeModeStretch is a ImageResizeMode of type Stretch.
	ImageResizeModeStretch
)

var ErrInvalidImageResizeMode = fmt.Errorf("not a valid ImageResizeMode, try [%s]", strings.Join(_ImageResizeModeNames, ", "))

const _ImageResizeModeName = "nonekeepARstretch"

var _ImageResizeModeNames = []string{
	_ImageResizeModeName[0:4],
	_ImageResizeModeName[4:10],
	_ImageResizeModeName[10:17],
}

// ImageResizeModeNames returns a list of possible string values of ImageResizeMode.
func ImageResizeModeNames() []string {
	tmp := make([]string, len(_ImageResizeModeNames))
	copy(tmp, _ImageResizeModeNames)
	return tmp
}

var _ImageResizeModeMap = map[ImageResizeMode]string{
	ImageResizeModeNone:    _ImageResizeModeName[0:4],
	ImageResizeModeKeepAR:  _ImageResizeModeName[4:10],
	ImageResizeModeStretch: _ImageResizeModeName[10:17],
}

// String implements the Stringer interface.
func (x ImageResizeMode) String() string {
	if str, ok := _ImageResizeModeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ImageResizeMode(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ImageResizeMode) IsValid() bool {
	_, ok := _ImageResizeModeMap[x]
	return ok
}

var _ImageResizeModeValue = map[string]ImageResizeMode{
	_ImageResizeModeName[0:4]:                    ImageResizeModeNone,
	strings.ToLower(_ImageResizeModeName[0:4]):   ImageResizeModeNone,
	_ImageResizeModeName[4:10]:                   ImageResizeModeKeepAR,
	strings.ToLower(_ImageResizeModeName[4:10]):  ImageResizeModeKeepAR,
	_ImageResizeModeName[10:17]:                  ImageResizeModeStretch,
	strings.ToLower(_ImageResizeModeName[10:17]): ImageResizeModeStretch,
}

// ParseImageResizeMode attempts to convert a string to a ImageResizeMode.
func ParseImageResizeMode(name string) (ImageResizeMode, error) {
	if x, ok := _ImageResizeModeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ImageResizeModeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ImageResizeMode(0), fmt.Errorf("%s is %w", name, ErrInvalidImageResizeMode)
}

// MustParseImageResizeMode converts a string to a ImageResizeMode, and panics if is not valid.
func MustParseImageResizeMode(name string) ImageResizeMode {
	val, err := ParseImageResizeMode(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x ImageResizeMode) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ImageResizeMode) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseImageResizeMode(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *ImageResizeMode) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// OutputFmtEpub2 is a OutputFmt of type Epub2.
	OutputFmtEpub2 OutputFmt = iota
	// OutputFmtEpub3 is a OutputFmt of type Epub3.
	OutputFmtEpub3
	// OutputFmtKepub is a OutputFmt of type Kepub.
	OutputFmtKepub
	// OutputFmtKfx is a OutputFmt of type Kfx.
	OutputFmtKfx
)

var ErrInvalidOutputFmt = fmt.Errorf("not a valid OutputFmt, try [%s]", strings.Join(_OutputFmtNames, ", "))

const _OutputFmtName = "epub2epub3kepubkfx"

var _OutputFmtNames = []string{
	_OutputFmtName[0:5],
	_OutputFmtName[5:10],
	_OutputFmtName[10:15],
	_OutputFmtName[15:18],
}

// OutputFmtNames returns a list of possible string values of OutputFmt.
func OutputFmtNames() []string {
	tmp := make([]string, len(_OutputFmtNames))
	copy(tmp, _OutputFmtNames)
	return tmp
}

var _OutputFmtMap = map[OutputFmt]string{
	OutputFmtEpub2: _OutputFmtName[0:5],
	OutputFmtEpub3: _OutputFmtName[5:10],
	OutputFmtKepub: _OutputFmtName[10:15],
	OutputFmtKfx:   _OutputFmtName[15:18],
}

// String implements the Stringer interface.
func (x OutputFmt) String() string {
	if str, ok := _OutputFmtMap[x]; ok {
		return str
	}
	return fmt.Sprintf("OutputFmt(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x OutputFmt) IsValid() bool {
	_, ok := _OutputFmtMap[x]
	return ok
}

var _OutputFmtValue = map[string]OutputFmt{
	_OutputFmtName[0:5]:                    OutputFmtEpub2,
	strings.ToLower(_OutputFmtName[0:5]):   OutputFmtEpub2,
	_OutputFmtName[5:10]:                   OutputFmtEpub3,
	strings.ToLower(_OutputFmtName[5:10]):  OutputFmtEpub3,
	_OutputFmtName[10:15]:                  OutputFmtKepub,
	strings.ToLower(_OutputFmtName[10:15]): OutputFmtKepub,
	_OutputFmtName[15:18]:                  OutputFmtKfx,
	strings.ToLower(_OutputFmtName[15:18]): OutputFmtKfx,
}

// ParseOutputFmt attempts to convert a string to a OutputFmt.
func ParseOutputFmt(name string) (OutputFmt, error) {
	if x, ok := _OutputFmtValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _OutputFmtValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return OutputFmt(0), fmt.Errorf("%s is %w", name, ErrInvalidOutputFmt)
}

// MustParseOutputFmt converts a string to a OutputFmt, and panics if is not valid.
func MustParseOutputFmt(name string) OutputFmt {
	val, err := ParseOutputFmt(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x OutputFmt) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *OutputFmt) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseOutputFmt(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *OutputFmt) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}

const (
	// TOCPagePlacementNone is a TOCPagePlacement of type None.
	TOCPagePlacementNone TOCPagePlacement = iota
	// TOCPagePlacementBefore is a TOCPagePlacement of type Before.
	TOCPagePlacementBefore
	// TOCPagePlacementAfter is a TOCPagePlacement of type After.
	TOCPagePlacementAfter
)

var ErrInvalidTOCPagePlacement = fmt.Errorf("not a valid TOCPagePlacement, try [%s]", strings.Join(_TOCPagePlacementNames, ", "))

const _TOCPagePlacementName = "nonebeforeafter"

var _TOCPagePlacementNames = []string{
	_TOCPagePlacementName[0:4],
	_TOCPagePlacementName[4:10],
	_TOCPagePlacementName[10:15],
}

// TOCPagePlacementNames returns a list of possible string values of TOCPagePlacement.
func TOCPagePlacementNames() []string {
	tmp := make([]string, len(_TOCPagePlacementNames))
	copy(tmp, _TOCPagePlacementNames)
	return tmp
}

var _TOCPagePlacementMap = map[TOCPagePlacement]string{
	TOCPagePlacementNone:   _TOCPagePlacementName[0:4],
	TOCPagePlacementBefore: _TOCPagePlacementName[4:10],
	TOCPagePlacementAfter:  _TOCPagePlacementName[10:15],
}

// String implements the Stringer interface.
func (x TOCPagePlacement) String() string {
	if str, ok := _TOCPagePlacementMap[x]; ok {
		return str
	}
	return fmt.Sprintf("TOCPagePlacement(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x TOCPagePlacement) IsValid() bool {
	_, ok := _TOCPagePlacementMap[x]
	return ok
}

var _TOCPagePlacementValue = map[string]TOCPagePlacement{
	_TOCPagePlacementName[0:4]:                    TOCPagePlacementNone,
	strings.ToLower(_TOCPagePlacementName[0:4]):   TOCPagePlacementNone,
	_TOCPagePlacementName[4:10]:                   TOCPagePlacementBefore,
	strings.ToLower(_TOCPagePlacementName[4:10]):  TOCPagePlacementBefore,
	_TOCPagePlacementName[10:15]:                  TOCPagePlacementAfter,
	strings.ToLower(_TOCPagePlacementName[10:15]): TOCPagePlacementAfter,
}

// ParseTOCPagePlacement attempts to convert a string to a TOCPagePlacement.
func ParseTOCPagePlacement(name string) (TOCPagePlacement, error) {
	if x, ok := _TOCPagePlacementValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _TOCPagePlacementValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return TOCPagePlacement(0), fmt.Errorf("%s is %w", name, ErrInvalidTOCPagePlacement)
}

// MustParseTOCPagePlacement converts a string to a TOCPagePlacement, and panics if is not valid.
func MustParseTOCPagePlacement(name string) TOCPagePlacement {
	val, err := ParseTOCPagePlacement(name)
	if err != nil {
		panic(err)
	}
	return val
}

// MarshalText implements the text marshaller method.
func (x TOCPagePlacement) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *TOCPagePlacement) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseTOCPagePlacement(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// AppendText appends the textual representation of itself to the end of b
// (allocating a larger slice if necessary) and returns the updated slice.
//
// Implementations must not retain b, nor mutate any bytes within b[:len(b)].
func (x *TOCPagePlacement) AppendText(b []byte) ([]byte, error) {
	return append(b, x.String()...), nil
}
